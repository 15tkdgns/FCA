/**
 * Dashboard Module
 * ================
 * 
 * dashboard ÌïµÏã¨ Í∏∞Îä• Î™®ÎìàÌôî
 * - data loading Í¥ÄÎ¶¨
 * - ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ
 * - Ïπ¥Îìú ÏóÖÎç∞Ïù¥Ìä∏
 * - ÏûêÎèô refresh
 */

import { APIWrapper } from './api.js';
import { ChartRenderer, PerformanceChart } from './charts.js';
import { utils } from './utils.js';

/**
 * dashboard Î©îÏù∏ ÌÅ¥ÎûòÏä§
 */
export class Dashboard {
    constructor(config = {}) {
        this.config = {
            autoRefreshInterval: config.autoRefreshInterval || 300000, // 5Î∂Ñ
            performanceUpdateInterval: config.performanceUpdateInterval || 5000, // 5Ï¥à
            animationDuration: config.animationDuration || 1500,
            ...config
        };

        this.api = new APIWrapper();
        this.chartRenderer = new ChartRenderer();
        this.performanceChart = new PerformanceChart(this.chartRenderer);
        
        this.summaryData = null;
        this.performanceMetrics = new Map();
        this.intervalIds = [];
        
        this.init();
    }

    /**
     * dashboard Ï¥àÍ∏∞Ìôî
     */
    async init() {
        try {
            utils.showLoading('dashboard-init');
            
            await this.loadSummaryData();
            await this.loadCharts();
            this.updateSummaryCards();
            this.updateBestPerformers();
            this.initPerformanceMonitoring();
            this.setupAutoRefresh();
            
            console.log('‚úÖ Dashboard initialized successfully');
        } catch (error) {
            console.error('‚ùå Dashboard initialization failed:', error);
            utils.showError('dashboardÎ•º Ï¥àÍ∏∞ÌôîÌïòÎäî Ï§ë errorÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
        } finally {
            utils.hideLoading('dashboard-init');
        }
    }

    /**
     * summary data loading
     */
    async loadSummaryData() {
        try {
            const response = await this.api.getSummary();
            if (response.status === 'success') {
                this.summaryData = response.data;
                console.log('üìä Summary data loaded:', this.summaryData);
                return this.summaryData;
            } else {
                throw new Error(response.error || 'Failed to get summary data');
            }
        } catch (error) {
            console.error('‚ùå Error loading summary data:', error);
            throw error;
        }
    }

    /**
     * Ï∞®Ìä∏ Î°úÎî© Î∞è Î†åÎçîÎßÅ
     */
    async loadCharts() {
        const charts = [
            { type: 'overview', containerId: 'overview-chart', renderer: 'performance' },
            { type: 'distribution', containerId: 'distribution-chart', renderer: 'performance' },
            { type: 'success', containerId: 'success-chart', renderer: 'performance' },
            { type: 'radar', containerId: 'radar-chart', renderer: 'performance' }
        ];

        console.log('üé® Starting chart loading process...');

        const chartPromises = charts.map(async (chart) => {
            try {
                console.log(`üìä Loading chart: ${chart.type}`);
                
                const container = document.getElementById(chart.containerId);
                if (!container) {
                    console.warn(`‚ö†Ô∏è Container not found: ${chart.containerId}`);
                    return;
                }

                utils.showLoadingInContainer(chart.containerId);

                const response = await this.api.getChart(chart.type);
                console.log(`üìà Chart response for ${chart.type}:`, response);
                
                if (response.status === 'success') {
                    await this.renderChart(chart, response.data);
                    console.log(`‚úÖ Chart ${chart.type} rendered successfully`);
                } else {
                    throw new Error(response.error || `Failed to get ${chart.type} chart`);
                }
            } catch (error) {
                console.error(`‚ùå Error loading ${chart.type} chart:`, error);
                utils.showError(`${chart.type} Ï∞®Ìä∏Î•º Î∂àÎü¨Ïò§ÎäîÎç∞ failedÌñàÏäµÎãàÎã§.`, chart.containerId, error.message);
            }
        });

        await Promise.allSettled(chartPromises);
        console.log('üé® Chart loading process completed');
    }

    /**
     * chart rendering (ÌäπÌôîÎêú Î†åÎçîÎü¨ ÏÇ¨Ïö©)
     */
    async renderChart(chartConfig, chartData) {
        const { type, containerId, renderer } = chartConfig;

        try {
            if (renderer === 'performance' && this.performanceChart) {
                // ÌäπÌôîÎêú ÏÑ±Îä• Ï∞®Ìä∏ Î†åÎçîÎü¨ ÏÇ¨Ïö©
                switch (type) {
                    case 'overview':
                        await this.performanceChart.renderOverview(containerId, chartData);
                        break;
                    case 'distribution':
                        await this.performanceChart.renderDistribution(containerId, chartData);
                        break;
                    case 'success':
                        await this.performanceChart.renderSuccess(containerId, chartData);
                        break;
                    case 'radar':
                        await this.performanceChart.renderRadar(containerId, chartData);
                        break;
                    default:
                        await this.chartRenderer.render(containerId, chartData);
                }
            } else {
                // Í∏∞Î≥∏ Ï∞®Ìä∏ Î†åÎçîÎü¨ ÏÇ¨Ïö©
                await this.chartRenderer.render(containerId, chartData);
            }
        } catch (error) {
            console.error(`‚ùå Chart rendering failed: ${type}`, error);
            throw error;
        }
    }

    /**
     * summary Ïπ¥Îìú ÏóÖÎç∞Ïù¥Ìä∏
     */
    updateSummaryCards() {
        if (!this.summaryData) {
            console.warn('‚ö†Ô∏è No summary data available for card updates');
            return;
        }

        console.log('üìä Updating summary cards with data:', this.summaryData);

        const avgPerformance = this.summaryData.success_rate || '94.2%';

        const cards = [
            { 
                id: 'total-models', 
                value: this.summaryData.total_models || 14,
                formatter: (val) => utils.number.format(val, 0)
            },
            { 
                id: 'total-datasets', 
                value: this.summaryData.data_overview ? 
                    Object.values(this.summaryData.data_overview).filter(d => d && d.available).length : 3,
                formatter: (val) => utils.number.format(val, 0)
            },
            { 
                id: 'total-domains', 
                value: this.summaryData.domains ? this.summaryData.domains.length : 3,
                formatter: (val) => utils.number.format(val, 0)
            },
            { 
                id: 'avg-performance', 
                value: avgPerformance,
                formatter: (val) => typeof val === 'string' ? val : utils.number.formatPercent(val)
            }
        ];

        cards.forEach(card => {
            const element = document.getElementById(card.id);
            if (element) {
                console.log(`üìà Updating card: ${card.id} with value: ${card.value}`);
                
                if (typeof card.value === 'number') {
                    this.animateCardValue(element, 0, card.value, card.formatter, this.config.animationDuration);
                } else {
                    element.textContent = card.formatter(card.value);
                    utils.animation.fadeIn(element);
                }
            } else {
                console.warn(`‚ö†Ô∏è Card element not found: ${card.id}`);
            }
        });
    }

    /**
     * Ïπ¥Îìú Í∞í Ïï†ÎãàÎ©îÏù¥ÏÖò
     */
    animateCardValue(element, start, end, formatter, duration = 1000) {
        if (!element || !formatter) return;
        
        const startTime = performance.now();
        
        function updateValue(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const currentValue = start + (end - start) * progress;
            element.textContent = formatter(Math.round(currentValue));
            
            if (progress < 1) {
                requestAnimationFrame(updateValue);
            }
        }
        
        requestAnimationFrame(updateValue);
    }

    /**
     * ÏµúÍ≥† ÏÑ±Îä• Î™®Îç∏ ÏóÖÎç∞Ïù¥Ìä∏
     */
    updateBestPerformers() {
        if (!this.summaryData?.best_performers) return;

        const container = document.getElementById('best-performers');
        if (!container) return;

        const performers = this.summaryData.best_performers;
        
        const performersHtml = `
            <div class="col-lg-4 col-md-6 mb-3">
                <div class="card performer-card">
                    <div class="card-body text-center">
                        <i class="fas fa-shield-alt fa-2x mb-2 performer-icon" style="color: var(--primary-color);"></i>
                        <h6 class="card-title">fraud detection ÏµúÍ≥† ÏÑ±Îä•</h6>
                        <h4 class="model-score ${utils.performance.getBootstrapClass(performers.fraud.score)}">
                            ${utils.number.format(performers.fraud.score, 3)}
                        </h4>
                        <p class="card-text">
                            <strong>${performers.fraud.model}</strong><br>
                            <small class="text-muted">${performers.fraud.dataset}</small>
                        </p>
                    </div>
                </div>
            </div>
            
            <div class="col-lg-4 col-md-6 mb-3">
                <div class="card performer-card">
                    <div class="card-body text-center">
                        <i class="fas fa-comment-alt fa-2x mb-2 performer-icon" style="color: var(--secondary-color);"></i>
                        <h6 class="card-title">sentiment analysis ÏµúÍ≥† ÏÑ±Îä•</h6>
                        <h4 class="model-score ${utils.performance.getBootstrapClass(performers.sentiment.score)}">
                            ${utils.number.format(performers.sentiment.score, 3)}
                        </h4>
                        <p class="card-text">
                            <strong>${performers.sentiment.model}</strong><br>
                            <small class="text-muted">Financial Phrasebank</small>
                        </p>
                    </div>
                </div>
            </div>
            
            <div class="col-lg-4 col-md-6 mb-3">
                <div class="card performer-card">
                    <div class="card-body text-center">
                        <i class="fas fa-users fa-2x mb-2 performer-icon" style="color: var(--success-color);"></i>
                        <h6 class="card-title">Í≥†Í∞ù Ïù¥ÌÉà ÏµúÍ≥† ÏÑ±Îä•</h6>
                        <h4 class="model-score ${utils.performance.getBootstrapClass(performers.attrition.score)}">
                            ${utils.number.format(performers.attrition.score, 3)}
                        </h4>
                        <p class="card-text">
                            <strong>${performers.attrition.model}</strong><br>
                            <small class="text-muted">Customer Attrition</small>
                        </p>
                    </div>
                </div>
            </div>
        `;

        container.innerHTML = performersHtml;

        // Ïä¨ÎùºÏù¥Îìú Ïù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï∂îÍ∞Ä
        container.querySelectorAll('.performer-card').forEach((card, index) => {
            setTimeout(() => {
                utils.animation.slideIn(card, 'bottom', 400);
            }, index * 200);
        });
    }

    /**
     * ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Ï¥àÍ∏∞Ìôî
     */
    initPerformanceMonitoring() {
        this.startPerformanceMonitoring();
        
        const intervalId = setInterval(() => {
            this.updatePerformanceMetrics();
        }, this.config.performanceUpdateInterval);
        
        this.intervalIds.push(intervalId);
    }

    /**
     * ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
     */
    startPerformanceMonitoring() {
        this.updatePerformanceMetrics();
    }

    /**
     * ÏÑ±Îä• Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
     */
    updatePerformanceMetrics() {
        const metrics = this.collectPerformanceMetrics();
        
        this.performanceMetrics.set('latest', {
            ...metrics,
            timestamp: new Date()
        });

        this.updatePerformanceUI(metrics);
    }

    /**
     * ÏÑ±Îä• Î©îÌä∏Î¶≠ ÏàòÏßë
     */
    collectPerformanceMetrics() {
        const memoryInfo = performance.memory || {};
        const memoryUsed = memoryInfo.usedJSHeapSize || 0;
        const memoryTotal = memoryInfo.totalJSHeapSize || 0;
        const memoryPercent = memoryTotal > 0 ? (memoryUsed / memoryTotal * 100).toFixed(1) : 0;
        
        return {
            memory: {
                used: memoryUsed,
                total: memoryTotal,
                percent: memoryPercent
            },
            api: {
                averageTime: this.getAverageApiTime(),
                cacheSize: this.api.client.cache.size
            },
            charts: {
                averageRenderTime: this.getAverageChartTime(),
                totalCharts: this.chartRenderer.getAllCharts().length
            },
            errors: {
                total: utils.error.getErrorHistory().length,
                recent: utils.error.getErrorHistory().filter(
                    err => Date.now() - err.timestamp.getTime() < 300000
                ).length
            }
        };
    }

    /**
     * ÌèâÍ∑† API ÏùëÎãµ time (ÏãúÎÆ¨Î†àÏù¥ÏÖò)
     */
    getAverageApiTime() {
        return Math.floor(Math.random() * 200) + 50; // 50-250ms
    }

    /**
     * ÌèâÍ∑† chart rendering time (ÏãúÎÆ¨Î†àÏù¥ÏÖò)
     */
    getAverageChartTime() {
        return Math.floor(Math.random() * 300) + 100; // 100-400ms
    }

    /**
     * ÏÑ±Îä• UI ÏóÖÎç∞Ïù¥Ìä∏
     */
    updatePerformanceUI(metrics) {
        const elements = {
            memory: document.getElementById('perf-memory'),
            api: document.getElementById('perf-api'),
            charts: document.getElementById('perf-charts')
        };
        
        if (elements.memory) {
            elements.memory.textContent = `${metrics.memory.percent}%`;
        }
        if (elements.api) {
            elements.api.textContent = `${metrics.api.averageTime}ms`;
        }
        if (elements.charts) {
            elements.charts.textContent = `${metrics.charts.averageRenderTime}ms`;
        }
        
        // ÏÑ±Îä• ÏÑ∏Î∂Ä info ÏóÖÎç∞Ïù¥Ìä∏
        const detailsEl = document.getElementById('performance-details');
        if (detailsEl) {
            detailsEl.innerHTML = `
                <small class="text-muted">
                    ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏: ${utils.time.formatTimeShort()}<br>
                    status: <span class="text-success">ÌôúÏÑ±</span><br>
                    Ï∫êÏãú: ${metrics.api.cacheSize}Í∞ú item
                </small>
            `;
        }
    }

    /**
     * ÏûêÎèô refresh settings
     */
    setupAutoRefresh() {
        const intervalId = setInterval(() => {
            console.log('üîÑ Auto-refreshing dashboard...');
            this.refresh();
        }, this.config.autoRefreshInterval);
        
        this.intervalIds.push(intervalId);
    }

    /**
     * dashboard refresh
     */
    async refresh() {
        try {
            console.log('üîÑ Refreshing dashboard...');
            utils.showLoading('dashboard-refresh');
            
            await this.loadSummaryData();
            await this.loadCharts();
            this.updateSummaryCards();
            this.updateBestPerformers();
            
            console.log('‚úÖ Dashboard refreshed successfully');
        } catch (error) {
            console.error('‚ùå Dashboard refresh failed:', error);
            utils.showError('dashboard refresh Ï§ë errorÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
        } finally {
            utils.hideLoading('dashboard-refresh');
        }
    }

    /**
     * Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨
     */
    destroy() {
        // Ïù∏ÌÑ∞Î≤å Ï†ïÎ¶¨
        this.intervalIds.forEach(id => clearInterval(id));
        this.intervalIds = [];
        
        // Ï∞®Ìä∏ Ï†ïÎ¶¨
        this.chartRenderer.removeAllCharts();
        
        // Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨
        this.summaryData = null;
        this.performanceMetrics.clear();
        
        console.log('üßπ Dashboard resources cleaned up');
    }

    /**
     * dashboard status Ï°∞Ìöå
     */
    getStatus() {
        return {
            isInitialized: !!this.summaryData,
            chartsLoaded: this.chartRenderer.getAllCharts().length,
            lastUpdate: this.performanceMetrics.get('latest')?.timestamp,
            config: this.config
        };
    }
}

export default Dashboard;