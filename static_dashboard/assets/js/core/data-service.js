/**
 * FCA Data Service - Core Data Access Layer
 * ========================================
 * 
 * ÏãúÎãàÏñ¥ Í∞úÎ∞úÏûêÍ∞Ä Íµ¨Ï∂ïÌïú Í≤¨Í≥†Ìïú Îç∞Ïù¥ÌÑ∞ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú
 * 
 * ÌåÄ Í∑úÏπô:
 * 1. ÏßÅÏ†ë fetch() ÏÇ¨Ïö© Í∏àÏßÄ - Î∞òÎìúÏãú DataService ÏÇ¨Ïö©
 * 2. ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞ Î°úÏßÅ ÏÉùÏÑ± Í∏àÏßÄ - Í∏∞Ï°¥ Î©îÏÑúÎìú ÌôúÏö©
 * 3. AIÍ∞Ä ÏûÑÏùòÎ°ú Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ Î≥ÄÍ≤Ω Í∏àÏßÄ
 * 
 * ÏÇ¨Ïö©Î≤ï:
 * const fraudData = await DataService.getFraudData();
 * const xaiData = await DataService.getXAIData();
 */

class DataService {
    constructor() {
        this.cache = new Map();
        this.loadingPromises = new Map();
        this.cacheTimeout = 10 * 60 * 1000; // 10Î∂Ñ Ï∫êÏãú
        this.maxRetries = 3;
        this.retryDelay = 1000;
        
        // ÏóîÎìúÌè¨Ïù∏Ìä∏ Ï†ïÏùò - ÏàòÏ†ï Í∏àÏßÄ
        this.endpoints = Object.freeze({
            FRAUD_DATA: 'data/fraud_data.json',
            XAI_DATA: 'data/xai_data.json', 
            SENTIMENT_DATA: 'data/sentiment_data.json',
            ATTRITION_DATA: 'data/attrition_data.json',
            PERFORMANCE_DATA: 'data/performance_metrics.json',
            BUNDLE_DATA: 'data/bundle.json',
            SUMMARY_DATA: 'data/summary.json',
            MODEL_DATA: 'data/model_data.json',
            BUSINESS_DATA: 'data/business_metrics.json',
            DATASET_METADATA: 'data/dataset_metadata.json'
        });

        // Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù Ïä§ÌÇ§Îßà
        this.schemas = Object.freeze({
            FRAUD_DATA: ['fraud_distribution', 'feature_importance'],
            XAI_DATA: ['lime_explanations', 'model_decision_process'],
            SENTIMENT_DATA: ['sentiment_distribution'],
            ATTRITION_DATA: ['attrition_prediction'],
            PERFORMANCE_DATA: ['model_performance'],
            BUNDLE_DATA: ['summary', 'fraud_data', 'xai_data']
        });

        this.init();
    }

    init() {
        this.log('üìä DataService initialized - Core data layer ready');
        this.startHealthCheck();
    }

    // ===========================================
    // ÌïµÏã¨ Îç∞Ïù¥ÌÑ∞ Ï†ëÍ∑º Î©îÏÑúÎìú (ÌåÄÏõê ÏÇ¨Ïö© ÌïÑÏàò)
    // ===========================================

    /**
     * ÏÇ¨Í∏∞ ÌÉêÏßÄ Îç∞Ïù¥ÌÑ∞ ÌöçÎìù
     * ÏÇ¨Ïö©: const data = await DataService.getFraudData();
     */
    async getFraudData() {
        return this.loadWithValidation('FRAUD_DATA', this.endpoints.FRAUD_DATA);
    }

    /**
     * XAI Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ ÌöçÎìù  
     * ÏÇ¨Ïö©: const data = await DataService.getXAIData();
     */
    async getXAIData() {
        return this.loadWithValidation('XAI_DATA', this.endpoints.XAI_DATA);
    }

    /**
     * Í∞êÏ†ï Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ ÌöçÎìù
     * ÏÇ¨Ïö©: const data = await DataService.getSentimentData();
     */
    async getSentimentData() {
        return this.loadWithValidation('SENTIMENT_DATA', this.endpoints.SENTIMENT_DATA);
    }

    /**
     * Ïù¥ÌÉà ÏòàÏ∏° Îç∞Ïù¥ÌÑ∞ ÌöçÎìù
     * ÏÇ¨Ïö©: const data = await DataService.getAttritionData();
     */
    async getAttritionData() {
        return this.loadWithValidation('ATTRITION_DATA', this.endpoints.ATTRITION_DATA);
    }

    /**
     * ÏÑ±Îä• Î©îÌä∏Î¶≠ Îç∞Ïù¥ÌÑ∞ ÌöçÎìù
     * ÏÇ¨Ïö©: const data = await DataService.getPerformanceData();
     */
    async getPerformanceData() {
        return this.loadWithValidation('PERFORMANCE_DATA', this.endpoints.PERFORMANCE_DATA);
    }

    /**
     * Î≤àÎì§ Îç∞Ïù¥ÌÑ∞ ÌöçÎìù (Î™®Îì† Îç∞Ïù¥ÌÑ∞ ÌÜµÌï©)
     * ÏÇ¨Ïö©: const data = await DataService.getBundleData();
     */
    async getBundleData() {
        return this.loadWithValidation('BUNDLE_DATA', this.endpoints.BUNDLE_DATA);
    }

    /**
     * ÎåÄÏãúÎ≥¥Îìú Ï¥àÍ∏∞Ìôî Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥Ñ Î°úÎìú
     * ÏÇ¨Ïö©: const allData = await DataService.loadDashboardData();
     */
    async loadDashboardData() {
        this.log('üöÄ Loading dashboard data with priority system');
        
        const criticalData = await this.loadCriticalData();
        const normalData = await this.loadNormalData();
        
        return {
            ...criticalData,
            ...normalData,
            loadTimestamp: new Date().toISOString()
        };
    }

    // ===========================================
    // ÎÇ¥Î∂Ä Íµ¨ÌòÑ (ÌåÄÏõê ÏßÅÏ†ë ÏÇ¨Ïö© Í∏àÏßÄ)
    // ===========================================

    async loadCriticalData() {
        const promises = [
            this.getFraudData().catch(e => this.handleCriticalError('fraud_data', e)),
            this.getXAIData().catch(e => this.handleCriticalError('xai_data', e))
        ];

        const [fraudData, xaiData] = await Promise.all(promises);
        
        return {
            fraud_data: fraudData,
            xai_data: xaiData
        };
    }

    async loadNormalData() {
        const promises = [
            this.getSentimentData().catch(e => this.getFallbackData('SENTIMENT_DATA')),
            this.getAttritionData().catch(e => this.getFallbackData('ATTRITION_DATA')),
            this.getPerformanceData().catch(e => this.getFallbackData('PERFORMANCE_DATA'))
        ];

        const [sentimentData, attritionData, performanceData] = await Promise.allSettled(promises);

        return {
            sentiment_data: this.extractValue(sentimentData),
            attrition_data: this.extractValue(attritionData),
            performance_data: this.extractValue(performanceData)
        };
    }

    async loadWithValidation(schemaKey, url) {
        const cacheKey = `validated_${url}`;
        
        // Ï∫êÏãú ÌôïÏù∏
        if (this.isCached(cacheKey)) {
            return this.getFromCache(cacheKey);
        }

        // Î°úÎî© Ï§ëÎ≥µ Î∞©ÏßÄ
        if (this.loadingPromises.has(cacheKey)) {
            return this.loadingPromises.get(cacheKey);
        }

        const loadingPromise = this.performLoadWithValidation(schemaKey, url);
        this.loadingPromises.set(cacheKey, loadingPromise);

        try {
            const data = await loadingPromise;
            this.setCache(cacheKey, data);
            return data;
        } finally {
            this.loadingPromises.delete(cacheKey);
        }
    }

    async performLoadWithValidation(schemaKey, url) {
        let lastError;
        
        for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
            try {
                const data = await this.fetchWithTimeout(url, 8000);
                this.validateData(data, schemaKey);
                
                this.log(`‚úÖ Data loaded and validated: ${url} (attempt ${attempt})`);
                return data;
                
            } catch (error) {
                lastError = error;
                this.log(`‚ö†Ô∏è Load attempt ${attempt} failed for ${url}: ${error.message}`);
                
                if (attempt < this.maxRetries) {
                    await this.delay(this.retryDelay * attempt);
                }
            }
        }
        
        throw new Error(`Failed to load ${url} after ${this.maxRetries} attempts: ${lastError.message}`);
    }

    async fetchWithTimeout(url, timeout = 5000) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        try {
            const response = await fetch(url, {
                signal: controller.signal,
                headers: {
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache'
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            return data;
            
        } finally {
            clearTimeout(timeoutId);
        }
    }

    validateData(data, schemaKey) {
        const requiredFields = this.schemas[schemaKey];
        if (!requiredFields) return;

        const missingFields = requiredFields.filter(field => !(field in data));
        if (missingFields.length > 0) {
            throw new Error(`Data validation failed. Missing fields: ${missingFields.join(', ')}`);
        }
    }

    // ===========================================
    // Ï∫êÏãú Í¥ÄÎ¶¨
    // ===========================================

    isCached(key) {
        const cached = this.cache.get(key);
        if (!cached) return false;
        
        const isExpired = Date.now() - cached.timestamp > this.cacheTimeout;
        if (isExpired) {
            this.cache.delete(key);
            return false;
        }
        
        return true;
    }

    getFromCache(key) {
        const cached = this.cache.get(key);
        return cached ? cached.data : null;
    }

    setCache(key, data) {
        this.cache.set(key, {
            data: data,
            timestamp: Date.now()
        });
    }

    clearCache(pattern = null) {
        if (pattern) {
            const regex = new RegExp(pattern);
            Array.from(this.cache.keys())
                .filter(key => regex.test(key))
                .forEach(key => this.cache.delete(key));
        } else {
            this.cache.clear();
        }
        this.log('üßπ Cache cleared');
    }

    // ===========================================
    // Ïò§Î•ò Ï≤òÎ¶¨ Î∞è Ìè¥Î∞±
    // ===========================================

    handleCriticalError(dataType, error) {
        this.log(`‚ùå Critical data load failed: ${dataType} - ${error.message}`, 'error');  
        throw new Error(`Critical system data unavailable: ${dataType}`);
    }

    getFallbackData(schemaKey) {
        const fallbacks = {
            FRAUD_DATA: {
                fraud_distribution: { legitimate: 95, fraudulent: 5 },
                feature_importance: [],
                timestamp: new Date().toISOString()
            },
            XAI_DATA: {
                lime_explanations: { fraud_detection: { features: [] } },
                model_decision_process: { fraud_detection: { decision_tree_path: [] } },
                timestamp: new Date().toISOString()
            },
            SENTIMENT_DATA: {
                sentiment_distribution: { positive: 40, neutral: 35, negative: 25 },
                timestamp: new Date().toISOString()
            },
            ATTRITION_DATA: {
                attrition_prediction: { risk_levels: [], features: [] },
                timestamp: new Date().toISOString()
            },
            PERFORMANCE_DATA: {
                model_performance: { accuracy: 0, precision: 0, recall: 0 },
                timestamp: new Date().toISOString()
            }
        };

        return fallbacks[schemaKey] || {};
    }

    extractValue(promiseResult) {
        return promiseResult.status === 'fulfilled' ? promiseResult.value : promiseResult.reason;
    }

    // ===========================================
    // Ïú†Ìã∏Î¶¨Ìã∞
    // ===========================================

    async delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    log(message, level = 'info') {
        const timestamp = new Date().toISOString();
        const prefix = level === 'error' ? '‚ùå' : level === 'warn' ? '‚ö†Ô∏è' : 'üìä';
        console.log(`${prefix} [DataService] ${message}`);
    }

    startHealthCheck() {
        setInterval(() => {
            const stats = this.getSystemStats();
            if (stats.cacheSize > 50) {
                this.log('üßπ Cache size high, clearing old entries');
                this.clearCache();
            }
        }, 5 * 60 * 1000); // 5Î∂ÑÎßàÎã§ Ï≤¥ÌÅ¨
    }

    getSystemStats() {
        return {
            cacheSize: this.cache.size,
            loadingInProgress: this.loadingPromises.size,
            cacheKeys: Array.from(this.cache.keys()),
            uptime: Date.now() - this.startTime || Date.now()
        };
    }

    // ===========================================
    // Í∞úÎ∞úÏûê ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨
    // ===========================================

    debug() {
        return {
            cache: Object.fromEntries(this.cache),
            loading: Array.from(this.loadingPromises.keys()),
            endpoints: this.endpoints,
            stats: this.getSystemStats()
        };
    }
}

// Ï†ÑÏó≠ Ïù∏Ïä§ÌÑ¥Ïä§ - ÌïòÎÇòÎßå ÏÉùÏÑ±
window.DataService = new DataService();

// Î™®Îìà ÏãúÏä§ÌÖú ÏßÄÏõê
if (typeof module !== 'undefined' && module.exports) {
    module.exports = DataService;
}

/**
 * ÌåÄ ÏÇ¨Ïö©Î≤ï ÏöîÏïΩ:
 * 
 * ‚úÖ Ïò¨Î∞îÎ•∏ ÏÇ¨Ïö©Î≤ï:
 * const fraudData = await DataService.getFraudData();
 * const xaiData = await DataService.getXAIData();  
 * const allData = await DataService.loadDashboardData();
 * 
 * ‚ùå Í∏àÏßÄÎêú ÏÇ¨Ïö©Î≤ï:
 * fetch('data/fraud_data.json') // ÏßÅÏ†ë fetch Í∏àÏßÄ
 * ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞ Î°úÏßÅ ÏûëÏÑ± // Í∏∞Ï°¥ Î©îÏÑúÎìú ÏÇ¨Ïö©
 * AIÏóêÍ≤å Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ Î≥ÄÍ≤Ω ÏöîÏ≤≠ // ÏãúÎãàÏñ¥ Í∞úÎ∞úÏûê ÏäπÏù∏ ÌïÑÏöî
 */